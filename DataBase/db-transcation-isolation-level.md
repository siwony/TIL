# 트랜잭션 격리 수준 - Isolation level
트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다

격리수준은 크게 4개로 나뉜다.
- [Read Uncommitted](#1-read-uncommitted)
- [Read Committed](#2-read-committed)
- [Repeatable Read](#3-repetable-read)
- [Serializable](#4-serializable)

위에서 아래로 갈수록 격리수준은 높아진다.

## 격리성 관련 문제점
### 1. Dirty Read
**다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것**

1. 트랜잭션 A가 1번 사원의 나이를 19 &rarr; 20로 변경하고 커밋하지 않았다.
2. 트랜잭션 B는 1번 사원의 나이를 조회했더니 커밋하지 않았던 20을 조회했다.

**만약 트랜잭션 A가 최종커밋을 하지 않는다면, 트랜잭션 B가 가지고 있는 데이터는 꼬이게된다.**

### 2. Non-Repeatable Read
트랜잭션 내에서 같은 쿼리를 두번 수행할 때 두개의 쿼리가 다른 결과를 반환하는 현상 (비 일관성)

1. 트랜잭션 A는 현재 1번 사원의 나이가 19인 데이터를 조회하고 있다.
2. 트랜잭션 B가 1번 사원의 나이를 19 &rarr; 20로 변경하고 커밋한다.
3. 그후 트랜잭션 A가 다시 해당 데이터를 조회 하면 처음 조회랑 다른 20으로 변경된 데이터를 조회하게 된다.

### 3. Phantom Read
한 트랜잭션 안에서 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다.

1. 트랜잭션 A가 특정 조건으로 데이터를 검색하여 결과를 얻었다.
2. 트랜잭션 B가 해당 조건의 데이터를 삭제 혹은 추가 해버렸다,
3. 다시 해당 조건으로 트랜잭션 A가 데이터를 조회하면 이전에 트랜잭션 A에서 추가/삭제된 데이터가 함께 조회/누락 된다.

**이 때 트랜잭션 B가 롤백하게 된다면 데이터가 꼬이게 된다.**

## 1. Read Uncommitted
어떤 트랜잭션의 처리중인 변경내용이 다른 트랜잭션에서 읽는 것을 허용한다.

#### 발생되는 문제점 
`Dirty Read`, `Non-Repeatable Read`, `Phantom Read`

## 2. Read Committed
어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.
> Oracle DBMS에서 기본으로 사용된다.

- 커밋 되지 않은 데이터에 대해서는 실제 DB 데이터가 아닌 Undo 로그에 있는 이전 데이터를 가져온다.

#### 발생되는 문제점들
`Non-Repeatable Read`, `Phantom Read`

금융 시스템에서 입/출금 과 연관된 금전적인 처리와 연결되어 있다면 문제가 발생할 수 있다.

## 3. Repetable Read
트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.
> MySQL DBMS에서 기본으로 사용한다.

1. A번 트랜잭션이 500000번 사원을 조회
2. B번 트랜잭션이 500000번 사원의 이름을 변경하고 커밋
3. A번 트랜잭션이 500000번 사원을 다시 조회
4. `언두 - Undo` 영역에 백업된 데이터 반환

즉, **자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된)것만 보게 되는 것 이다.**

#### 발생되는 문제점
`Phantom Read`

## 4. Serializable
격리수준이 Serializable일 경우 **읽기 작업에도 공유 잠금**을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.

- 동시처리 능력이 떨어진다.
- 성능저하가 발생하게 된다.